# -*- coding: utf-8 -*-
"""Asignación 1 Métodos I Isabella Rodriguez y Santiago Conde.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HDBxqdAfQNQkXcZqFFX-t57atTlnP9UX
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files

# Subimos los archivos en el pc
uploaded = files.upload()

# Cargamos el archivo de los datos de AMB
archivo_amb = [f for f in uploaded.keys() if "AMB" in f][0]
amb = pd.read_csv(archivo_amb)
amb["Date&Time"] = pd.to_datetime(amb["Date&Time"], errors="coerce", dayfirst=True).dt.tz_localize(None)
# Eliminamos las filas que tengan "NoData" o que no tengan datos y los ordenamos
amb["PM2.5"] = pd.to_numeric(amb["PM2.5"], errors="coerce")
amb = amb.dropna(subset=["Date&Time", "PM2.5"])
amb = amb.sort_values("Date&Time")

# Cargamos todos los archivos de las mediciones de Iot
archivos_iot = [f for f in uploaded.keys() if f.startswith("mediciones")]
dfs = []
for file in archivos_iot:
    df = pd.read_csv(file)
    df["fecha_hora_med"] = pd.to_datetime(df["fecha_hora_med"], errors="coerce").dt.tz_localize(None)
    df["valor"] = pd.to_numeric(df["valor"], errors="coerce")
    df = df.dropna(subset=["fecha_hora_med", "valor"])
    dfs.append(df)

# Unimos todos los archivos de Iot para generar uno solo y poder graficar
iot_total = pd.concat(dfs, ignore_index=True)
iot_total = iot_total.sort_values("fecha_hora_med")

# Gráfica de datos de AMB
plt.figure(figsize=(12,6))
plt.plot(amb["Date&Time"], amb["PM2.5"], color="black", linewidth=2)
plt.xlabel("Tiempo")
plt.ylabel("PM 2.5 (µg/m³)")
plt.title("PM 2.5 - Estación de referencia AMB")
plt.grid(True)
plt.show()

# Gráfica de datos de Iot
plt.figure(figsize=(12,6))
plt.plot(iot_total["fecha_hora_med"], iot_total["valor"], color="blue", alpha=0.7)
plt.xlabel("Tiempo")
plt.ylabel("PM 2.5 (µg/m³)")
plt.title("PM 2.5 - Estaciones IoT (unidas)")
plt.grid(True)
plt.show()

# Código para cálculo de moving average
import math

#Lo primero que haremos será pasar de pandas a numpy para trabajar con mayor facilidad
amb_segundos = amb["Date&Time"].values.astype("datetime64[s]").astype(np.int64)
amb_valores = amb["PM2.5"].to_numpy(dtype=float)
iot_segundos = iot_total["fecha_hora_med"].values.astype("datetime64[s]").astype(np.int64)
iot_valores = iot_total["valor"].to_numpy(dtype=float)

# Definimos el ancho de ventana y el solapamiento (paso) (medidos en minutos)
ancho_ventana = 720
paso = 360
solapamiento = ancho_ventana - paso

ancho_segundos = ancho_ventana * 60
paso_segundos = paso * 60
solapamiento_segundos = solapamiento * 60


# Elegimos el rango temporal para realizar el moving average
inicio = max(amb_segundos.min(), iot_segundos.min()) #Hallamos el valor máximo entre los valores iniciales de los datos amb e Iot
fin   = min(amb_segundos.max(), iot_segundos.max()) #Hallamos el valor mínimo entre los valores finales

print("Rango común (datetime):", pd.to_datetime(inicio, unit='s'), "->", pd.to_datetime(fin, unit='s'))
print(f"Ancho ventana = {ancho_ventana} min ({ancho_segundos}s), paso = {paso} min ({paso_segundos}s), solapamiento = {solapamiento} min ({solapamiento_segundos}s)\n")

# Ahora construiremos las ventanas:
inicio = int(inicio)
final   = int(fin)

# Primero redondeamos al minuto más cercano
inicial = inicio - (inicio % 60)

ventanas = []
a = inicial
while a + ancho_segundos <= final:
    b = a + ancho_segundos
    centro = a + ancho_segundos // 2
    ventanas.append((a, b, centro))
    a = a + paso_segundos

print(f"Total de ventanas (entero-segundos): {len(ventanas)}")
print("Primeras 5 ventanas (a, b, centro):") # Esto lo hacemos para verificar que los resultados de las operaciones del código sean los deseados
for i, (a,b,c) in enumerate(ventanas[:5]):
    print(f"{i+1:02d}) {pd.to_datetime(a, unit='s')} -> {pd.to_datetime(b, unit='s')}   centro: {pd.to_datetime(c, unit='s')}")

# Ahora calcularemos las medias para cada ventana:
medias = []
numero_amb = len(amb_segundos)
numero_iot = len(iot_segundos)

for (a, b, centro) in ventanas:
    suma_amb = 0.0
    cuenta_amb = 0
    # Media para los datos de AMB
    for i in range(numero_amb):
        t = int(amb_segundos[i])
        if (t >= a) and (t < b):
            suma_amb += float(amb_valores[i])
            cuenta_amb += 1
    if cuenta_amb == 0:
        media_amb = float('nan')
    else:
        media_amb = suma_amb / cuenta_amb

    # Media para los datos de Iot
    suma_iot = 0.0
    cuenta_iot = 0
    for i in range(numero_iot):
        t = int(iot_segundos[i])
        if (t >= a) and (t < b):
            suma_iot += float(iot_valores[i])
            cuenta_iot += 1
    if cuenta_iot == 0:
        media_iot = float('nan')
    else:
        media_iot = suma_iot / cuenta_iot

    medias.append({
        'centro_s': centro,
        'centro_dt' : pd.to_datetime(centro, unit='s'),
        'media_amb': media_amb,
        'media_iot': media_iot
    })

# Al igual que la vez anterior, mostramos los primeros 5 resultados para verificar que los resultados de las operaciones del código sean los deseados
print("\nPrimeras 5 ventanas con sus medias:")
for i in medias[:5]:
    print(i['centro_dt'], " | AMB:", i['media_amb'], " µg/m³", " | IoT:", i['media_iot'], " µg/m³")

# Ahora emparejaremos las ventanas para poder hallar las distancias entre datos de AMB y de Iot:
conteo_emparejados = 0 #La importancia en buscar los emparejados está en que no contamos con los datos de algunas fechas en los registros de Iot y que sí están en los registros del AMB
suma_cuad = 0.0
suma_abs = 0.0
pares_muestra = []

for i in medias:
    m_a = i['media_amb']
    m_i = i['media_iot']
    # comprobamos que ambos archivos cuenten que información sobre los registros para las fechas dadas
    if (not (isinstance(m_a, float) and math.isnan(m_a))) and (not (isinstance(m_i, float) and math.isnan(m_i))):
        d = float(m_a) - float(m_i)
        conteo_emparejados += 1
        suma_cuad += d * d
        suma_abs += abs(d)
        if len(pares_muestra) < 5:
            pares_muestra.append({
                'centro': i['centro_dt'],
                'media_amb': m_a,
                'media_iot': m_i,
                'diferencia': d
            })

if conteo_emparejados == 0:
    print("\nNo hay ventanas emparejadas con datos en ambas series.")
else:
    # Calculamos la distancia entre los datos y el Error Absoluto Medio
    D = suma_cuad ** 0.5
    EAM = suma_abs / conteo_emparejados

    print("\nResultados sobre ventanas emparejadas:")
    print("Número de pares válidos:", conteo_emparejados)
    print("Distancia euclídea (D):", D, " µg/m³")
    print("Error absoluto medio:", EAM, " µg/m³")

    # Ejemplo
    print("\nPrimeros 5 pares válidos:")
    for p in pares_muestra:
        print(p['centro'], "| AMB:", p['media_amb'], " µg/m³", "| IoT:", p['media_iot'], " µg/m³", "| diferencia:", p['diferencia'], " µg/m³")

# Ahora graficaremos las medias por ventana
centers_plot = []
amb_plot = []
iot_plot = []

for m in medias:
    if not (isinstance(m['media_amb'], float) and math.isnan(m['media_amb'])) and not (isinstance(m['media_iot'], float) and math.isnan(m['media_iot'])):
        centers_plot.append(m['centro_dt'])
        amb_plot.append(m['media_amb'])
        iot_plot.append(m['media_iot'])

if len(centers_plot) > 0:
    plt.figure(figsize=(12,5))
    plt.plot(centers_plot, amb_plot, marker='o', linestyle='-', label='AMB (media ventana)')
    plt.plot(centers_plot, iot_plot, marker='o', linestyle='--', label='IoT (media ventana)')
    plt.xlabel('Centro de ventana')
    plt.ylabel('PM2.5 (µg/m³)')
    plt.title(f'Medias por ventana - ancho={ancho_ventana}min, paso={paso}min (ejemplo)')
    plt.legend()
    plt.grid(True)
    plt.show()
else:
    print("No hay ventanas emparejadas con datos en ambas series para graficar.")

import scipy.stats as st

# Extraemos las listas de promedios válidos
x_iot = []
y_amb = []
for i in medias:
    if (not (isinstance(i['media_amb'], float) and math.isnan(i['media_amb']))) and \
       (not (isinstance(i['media_iot'], float) and math.isnan(i['media_iot']))):
        x_iot.append(i['media_iot'])
        y_amb.append(i['media_amb'])

x_iot = np.array(x_iot)
y_amb = np.array(y_amb)

# Pendiente forzada al origen
m = np.sum(x_iot * y_amb) / np.sum(x_iot**2)

# Predicciones
y_pred = m * x_iot

print("\nModelo lineal forzado al origen:")
print(f"y = {m:.4f} * x")

# --- Errores ---
residuos = y_amb - y_pred

# Distancia según definición del taller
D = np.sqrt(np.sum(residuos**2))

# Error absoluto medio (MAE)
mae = np.mean(np.abs(residuos))

# Coeficiente de determinación
r2 = 1 - np.sum(residuos**2) / np.sum((y_amb - np.mean(y_amb))**2)

print("\nEvaluación del modelo:")
print(f"Distancia (D): {D:.4f} µg/m³")
print(f"Error absoluto medio (MAE): {mae:.4f} µg/m³")
print(f"Coeficiente de determinación R²: {r2:.4f}")

# Alcance del modelo
tolerancia = 5.0  # µg/m³
errores_abs = np.abs(residuos)
validos = errores_abs <= tolerancia

if np.any(validos):
    # Alcance en valores IoT
    x_validos = x_iot[validos]
    alcance_min = np.min(x_validos)
    alcance_max = np.max(x_validos)

    # Alcance en tiempo (usando las fechas de las ventanas)
    tiempos_validos = [medias[i]['centro_dt'] for i, ok in enumerate(validos) if ok]
    tiempo_min = min(tiempos_validos)
    tiempo_max = max(tiempos_validos)
    alcance_tiempo = tiempo_max - tiempo_min

    print(f"\nCon una tolerancia de {tolerancia} µg/m³:")
    print(f"- El modelo es válido en valores de IoT entre {alcance_min:.2f} y {alcance_max:.2f} µg/m³")
    print(f"- El modelo es válido en el intervalo de tiempo: {tiempo_min} → {tiempo_max}, es decir, en un tiempo de {alcance_tiempo}")
else:
    print(f"\nCon una tolerancia de {tolerancia} µg/m³, el modelo no es válido en ningún rango.")
    alcance_tiempo = 0.0

# Gráfica
plt.figure(figsize=(8,6))
plt.scatter(x_iot, y_amb, color="blue", label="Datos promedios (IoT vs AMB)", s=10)
plt.plot(x_iot, y_pred, color="red", label=f"Regresión lineal\ny = {m:.2f}x\nR²={r2:.2f}")
plt.xlabel("PM 2.5 IoT [µg/m³]")
plt.ylabel("PM 2.5 AMB [µg/m³]")
plt.title("Regresión lineal entre IoT y AMB")
plt.legend()
plt.grid(True)
plt.show()

resultados= [] # Lista para almacenar los resultados y decidir cual es el mas óptimo
n = len(x_iot)
porcentajes = [0.5, 0.35, 0.2]

for i in porcentajes:
    # División en entrenamiento y validación
    n_train = int(n * i)
    x_train = x_iot[:n_train]
    y_train = y_amb[:n_train]
    x_test = x_iot[n_train:]
    y_test = y_amb[n_train:]

    # Regresión lineal forzada al origen
    m = np.sum(x_train * y_train) / np.sum(x_train**2)
    y_pred = m * x_test  # predicciones sobre validación

    print(f"\n=== Porcentaje entrenamiento: {i*100:.0f}% ===")
    print(f"Modelo lineal forzado al origen: y = {m:.4f} * x")

    # --- Errores  ---
    residuos = y_test - y_pred
    D = np.sqrt(np.sum(residuos**2))
    mae = np.mean(np.abs(residuos))
    r2 = 1 - np.sum(residuos**2) / np.sum((y_test - np.mean(y_test))**2)

    print("\nEvaluación del modelo:")
    print(f"Distancia (D): {D:.4f} µg/m³")
    print(f"Error absoluto medio (MAE): {mae:.4f} µg/m³")
    print(f"Coeficiente de determinación R²: {r2:.4f}")

    # Alcance del modelo
    tolerancia = 5.0  # µg/m³
    errores_abs = np.abs(residuos)
    validos = errores_abs <= tolerancia

    if np.any(validos):
        x_validos = x_test[validos]
        alcance_min = np.min(x_validos)
        alcance_max = np.max(x_validos)
        alcance_IoT = alcance_max - alcance_min
        tiempos_validos = [medias[n_train + i]['centro_dt'] for i, ok in enumerate(validos) if ok]
        tiempo_min = min(tiempos_validos)
        tiempo_max = max(tiempos_validos)
        alcance_tiempo = tiempo_max - tiempo_min

        print(f"\nCon una tolerancia de {tolerancia} µg/m³:")
        print(f"- Alcance en valores IoT: {alcance_min:.2f} - {alcance_max:.2f} µg/m³")
        print(f"- Alcance en tiempo: {tiempo_min} → {tiempo_max}, es decir, en un tiempo de {alcance_tiempo}")
    else:
        print(f"\nCon una tolerancia de {tolerancia} µg/m³, el modelo no es válido en ningún rango.")
        alcance_IoT = 0.0
        alcance_tiempo = 0.0

    # Guardando resultados
    resultados.append({
        "Porcentaje": i,
        "Distancia": D,
        "MAE": mae,
        "R2": r2,
        "Alcance_IoT": alcance_IoT,
        "Alcance_Tiempo": alcance_tiempo
        })
    # Gráfica
    plt.figure(figsize=(8,6))
    plt.scatter(x_iot, y_amb, color="blue", label="Datos promedios (IoT vs AMB)", s=10)
    plt.plot(x_test, y_pred, color="red",
             label=f"Regresión lineal\ny = {m:.2f}x\nR²={r2:.2f}")
    plt.xlabel("PM 2.5 IoT [µg/m³]")
    plt.ylabel("PM 2.5 AMB [µg/m³]")
    plt.title(f"Regresión lineal - {i*100:.0f}% entrenamiento")
    plt.legend()
    plt.grid(True)
    plt.show()

# --- Comparación de modelos ---

def normalizar(lista, invertido=False):
    minimo, maximo = min(lista), max(lista)
    if maximo == minimo:  # evitar división por cero
        return [1.0]*len(lista)
    norm = [(x - minimo)/(maximo - minimo) for x in lista]
    if invertido:  # para métricas a minimizar
        norm = [1 - v for v in norm]
    return norm

# Extraemos listas de métricas
alcance_iot_list = [r['Alcance_IoT'] for r in resultados]
alcance_tiempo_list = [
    r['Alcance_Tiempo'].total_seconds() if r['Alcance_Tiempo'] != 0 else 0
    for r in resultados
]
mae_list = [r['MAE'] for r in resultados]
distancia_list = [r['Distancia'] for r in resultados]

# Normalizamos
alcance_iot_norm = normalizar(alcance_iot_list)
alcance_tiempo_norm = normalizar(alcance_tiempo_list)
mae_norm = normalizar(mae_list, invertido=True)
distancia_norm = normalizar(distancia_list, invertido=True)

# Escenarios de pesos
escenarios = {
    "Neutral (25% cada uno)": [0.25, 0.25, 0.25, 0.25],
    "Precisión (MAE,D con más peso)": [0.15, 0.15, 0.35, 0.35],
    "Alcance (IoT, tiempo con más peso)": [0.35, 0.35, 0.15, 0.15],
}

# Evaluamos cada escenario
for nombre, pesos in escenarios.items():
    print(f"\n=== Escenario: {nombre} ===")
    for i, r in enumerate(resultados):
        score = (pesos[0]*alcance_iot_norm[i] +
                 pesos[1]*alcance_tiempo_norm[i] +
                 pesos[2]*mae_norm[i] +
                 pesos[3]*distancia_norm[i])
        r[f'Score_{nombre}'] = score

    # Elegimos el mejor modelo para este escenario
    mejor_modelo = max(resultados, key=lambda x: x[f'Score_{nombre}'])

    for r in resultados:
        print(f"{r['Porcentaje']*100:.0f}% entrenamiento -> "
              f"MAE: {r['MAE']:.4f}, D: {r['Distancia']:.4f}, "
              f"Alcance IoT: {r['Alcance_IoT']:.2f}, Alcance tiempo: {r['Alcance_Tiempo']}, "
              f"Score: {r[f'Score_{nombre}']:.3f}")

    print(f"\nMejor modelo en {nombre}: {mejor_modelo['Porcentaje']*100:.0f}% entrenamiento")

# Creando un DataFrame
df = pd.DataFrame({
    "Promedios Locales AMB [µg/m³]": y_amb,
    "Promedios Locales IoT [µg/m³]": x_iot,
})

# Guardando en excel
df.to_excel("Promedios.xlsx", index=False)

# Descargando
files.download("Promedios.xlsx")

